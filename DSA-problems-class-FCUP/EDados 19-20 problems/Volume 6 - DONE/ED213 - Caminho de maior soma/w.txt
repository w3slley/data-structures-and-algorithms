import java.util.LinkedList;
import java.util.Stack;
class Path{
    public int sum;
    public String path;
    
    Path(int sum, String path){
	this.path = path;
	this.sum = sum;
    }
    public String toString(){
	return "{"+sum+","+path+"}";
    }
}
class ED213{
    static Stack<Integer> nodeStack;
    static Stack<Character> pathStack;
    static LinkedList<Path> paths;
    
    public static String getPath(Stack<Character> stack){
	String str = "";
	int n = stack.size();
	char[] arr = new char[n];
	//adding char values from stack to array
	for(int i=0;i<n;i++){
	    char val = stack.pop();
	    arr[n-i-1] = val;
	}
	//putting items back into stack and adding path to string
	for(int i=0;i<n;i++){
	    stack.push(arr[i]);
	    str+=arr[i];
	}
	return str;
    }
    public static int sumStack(Stack<Integer> stack){ //O(n+n) = O(n)
	int sum = 0;
	int n = stack.size();
	int[] arr = new int[n];
	for(int i=0;i<n;i++){
	    int val = stack.pop();
	    sum += val;
	    arr[i] = val;
	}
	for(int i=0;i<n;i++) stack.push(arr[n-i-1]);//add values back into stack starting from end of array
	return sum;
    }

    public static Path getMaxPath(LinkedList<Path> l){
	Path maxPath = l.get(0);
	for(int i=1;i<l.size();i++)
	    if(l.get(i).sum > maxPath.sum) maxPath = l.get(i);
	
	return maxPath;
    }
    
    //O(n) - algorithm has to go through each of the n nodes of the binary tree
    public static void maxSum(BTree<Integer> t){
	nodeStack = new Stack<>();//stack to store node's values from root - to calculate sum
	pathStack = new Stack<>();//stack to store the path (E or D) from root - to return
	paths = new LinkedList<>();//linked list to store paths object
	maxSum(t.getRoot());
	System.out.println(paths);
	System.out.println(getMaxPath(paths).path);
    }
    private static void maxSum(BTNode<Integer> n){
	nodeStack.push(n.getValue());//pushing each root node to stack
	System.out.println(nodeStack);
	System.out.println(pathStack);
	if(n.getLeft() == null && n.getRight() == null){//when arrived at a leaf
	    Path p = new Path(sumStack(nodeStack), getPath(pathStack));
	    paths.addLast(p);
	    nodeStack.pop();
	    pathStack.pop();
	    return;
	}
	//only go to left subtree if it's not null
        if(n.getLeft() != null){
	    pathStack.add('E');
	    maxSum(n.getLeft());
	}
	//only go to right subtree if it's not null
	if(n.getRight() != null){
	    pathStack.add('D');
	    maxSum(n.getRight());
	}
	//removing item on top of stack (both on nodes and paths stack) when moving one height up in the tree
	nodeStack.pop();
        if(!pathStack.empty()) pathStack.pop();
    }
}
